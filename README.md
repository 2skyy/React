# 이하늘 202230231

## 6월12일 강의

# Css란

css 는 cascading style sheets의 약자로 스타일링을 위한 언어입니다.
cascading이란 계단식이라는 뜻으로 한 엘리먼트에 여러 스타일이 적용될 경우 스타일간의 충돌을 막기 위해 계단식으로 스타일을 적용시키는 규칙을 갖고 있습니다.
즉 하나의 스타일이 여러 개의 엘리먼트에 적용될 수도 있고, 하나의 엘리먼트에도 여러 개의 스타일이 적용될 수도 있습니다.
엘리먼트에 스타일이 적용되는 규칙을 selector(선택자)라고 합니다. css는 이 선택자와 스타일로 이루어 집니다.
이번 장에서는 선택자와 스타일을 카테고리별로 나누어 학습합니다.

# css문법과 선택자

선택자를 먼저 쓰고 다음에 적용할 스타일을 중괄호 안에 세미콜론으로 구분하여 하나씩 작성합니다.
선택자는 HTML엘리먼트를 직접 넣어도 되고, 엘리먼트의 조합 혹은 class의 형태로 작성 가능합니다.
스타일은 property(속성), key value(키값) 으로 이루어 지며, 이들은 콜론 으로 구분하고 각 스타일은 세미콜론으로 구분합니다.

hover : 마우스 커서가 엘리먼트 위에 올라왔을 때를 의미합니다.
active는 주로 <a> 태그(link) 에 사용되는데 엘리먼트가 클릭 됐을 때를 의미합니다.
focus는 주로 <input> 태그에서 사용되는데 말 그대로 엘리먼트가 초점을 갖고 있을 경우를 의미합니다.
checked는 radio button이나 checkbox같은 유형의 <input> 태그가 체크되어 있는 경우를 나타냅니다.

# 레이아웃과 관련된 속성

화면에 엘리먼트를 어떻게 배치할 것인지를 정의합니다.
가장 중요한 속성은 display입니다.
모든 엘리먼트는 기본 display 속성을 갖고 있지만 이 기본값을 변경해 줄 수 있습니다.
div{
display : none | block | inline | flex;
}

none는 존재는 하지만 화면에 보이지 않는 것으로, 자바스크립트를 넣을 때 많이 사용합니다.
block은 세로로 정렬되며, with의 height를 갖을 수 있다. 크기와 상관없이 한 줄을 점유합니다.
inline은 가로로 정렬되며, height와 width를 갖을 수 없다. 컨텐츠의 크기만큼 공간을 점유합니다.
inline-block는 기본적으로 inline의 특성을 갖지만, with와 height 등 block의 특성을 사용할 수 잇습니다.

대표적인 block과 inline 태그는 다음과 같습니다.

block : <div><table><h1~h6><p><form><ul><ol><li><dl><dt><dd><pre>등
inline: <span><a><br><em><strong><input><label><img>

flex는 컨테이너의 형태로 엘리먼트를 관리합니다.

최근 들어서는 Grid를 많이 사용합니다. Flex가 1차원 적이라면 Grid는 2차원적으로 관리가 가능하기 때문입니다.

visivility 속성은 엘리먼트의 가시성을 정의합니다.
div{
visibility : visible | hidden ;
}

여기서 중요한 것은 display:none 과 visibility:hidden 의 차이입니다.
display:none은 엘리먼트를 화면에서 보이지 않게 하는 것입니다.

엘리먼트의 크기를 나태나는 속성입니다.
div{
width: auto | value;
}

# styled-components

css 문법을 그대로 사용햐면서 결과물을 스타일링 된 컴포넌트 형태로 만들어 주는 오픈소스 라이브러리 입니다.
컴포넌트의 개념을 사용하고 있어 리액트 개발에 많이 사용됩니다.

# styled-components 설치하기

npm install--save styled components

교재에는 위와 같이나와 있지만, npm v5 부터는 사용하지 않아도 됩니다. (자동추가)

## 6월 11일 강의

# Specialization(특수화, 전문화)

웰컴 다이얼로그는 다이얼로그의 특별한 케이스입니다.
범용적인 개념을 구별이 되게 구체화하는 것을 특수화 라고 합니다.
객체지향 언어에서는 상속을 사용하여 특수화를 구현합니다.
리액트에서는 합성을 사용하여 특수화를 구현합니다.

# containment 와 specialization을 같이 사용하기

containment를 위해서 props.children을 사용하고 , specialization을 위해 직접 정의한 props를 사용하면 됩니다.
376p의 코드를 참고합니다.
dialog 컴포넌트는 이전의 것과 비슷한데 containment를 위해 끝부분에 props.children을 추가했습니다.
dialog를 사용하는 signupDialog는 Specialization을 위해 props.title과 props.message를 추가했습니다.
입력을 받기 위해 input과 button을 사용했습니다.
이 두개의 태그는 모두 props.children으로 전달되어 다이얼 로그에 표시됩니다.
이러한 형태로 containment와 specialization을 같이 사용하면 됩니다.

# 상속에 대해 알아보기

합성과 대비되는 개념으로 상속이 있습니다.
자식 클래스는 부모 클래스가 가진 변수나 함수 등의 속성을 모두 갖게 되는 개념입니다.
하지만 리액트에서는 상속보다는 합성을 통해 새로운 컴포넌트를 생성합니다.

복잡한 컴포넌트를 쪼개 여러개의 컴포넌트로 만들고, 만든 컴포넌트들을 조합하여 새로운 컴포넌트를 만들자.

# 컨텍스트란 무엇인가 ?

기존의 일반적인 리액트에서는 데이터가 컴포넌트의 props를 통해 부모에서 자식으로 단방향으로 전달되었습니다.
컨텍스트는 리액트 컴포넌트들 사이에서 데이터를 기존의 props 를 통해 전달하는 방식 대신 컴포넌트 트리를 통해 곧바로 컴포넌트애 전달하는 새로운 방식을 제공합니다.
이것을 통해 어떤 컴포넌트라도 쉽게 데이터에 접근할 수 있습니다.
컨택스트를 사용하면 일일이 props로 전달할 필요 없이 그림처럼 데이터를 필요로 하는 컴포넌트에 데이터를 전달할 수 있습니다.

# 언제 컨텍스트를 사용해야 할까 ?

여러 컴포넌트에서 자주 필요로 하는 데이터는 로그인 여부, 로그인 정보, UI테마, 현재 선택된 언어 등이 있습니다.
이런 데이터들을 기존의 방식대로 컴포넌트의 props를 통해 넘겨주는 예를 페이지 382에서 보여주고 있습니다.
예제에서 처럼 props를 통해 데이터를 전달하는 기존 방식은 실제 데이터를 필요로 하는 컴포넌트까지의 깊이가 깊어질수록 복잡해 집니다.
또한 반복적인 코드를 계속해서 작성해주어야 하기 때문에 비효율적이고 가독성이 떨어집니다.
컨텍스트를 사용하면 이러한 방식을 깔끔하게 개선할 수 있습니다.

페이지383의 예제는 컨텍스트를 사용한 예입니다.
react.createContext를 사용하여 컨텍스트를 생성하고, 이 컨텍스트를 사용하는 컴포넌트에 데이터를 전달합니다.
컨텍스트를 사용하려면 컴포넌트의 상위 컴포넌트에서 porvider로 감싸주어야합니다.

예제에서는 최상위 컴포넌트인 App에서 데이터를 전달하는데, 이것을 Provider라고 부릅니다.

# 컨텍스트를 사용하기 전에 고려할 점

컨텍스트는 다른 레벨의 많은 컴포넌트가 특정 데이터를 필요로 하는 경우에 주로 사용합니다.
하지만 무조건 컨텍스트를 사용하는 것이 좋은 것은 아닙니다.
왜냐하면 컴포넌트와 컨텍스트가 연동되면 재사용성이 떨어지기 때문입니다.
따라서 다른 레벨의 많은 컴포넌트가 특정 데이터를 필요로 하는 경우가 아니면 props를 통해 데이터를 전달하는 컴포넌트 합성 방법이 더 적합합니다.

페이지 395의 예제처럼 실제 user와 avatarsize를 사용하는 것은 avatar 컴포넌트 뿐인데 여러 단계에 걸쳐 props를 전달하고 있습니다.
이런 경우 컨텍스트를 사용하지 않고 문제를 해결할 수 있는 방법은 avatar 컴포넌트를 변수에 저장하여 직접 넘겨주는 것입니다.
이렇게 하면 중간 단계의 컴포넌트들은 user와 avatarsIze에 대해 몰라도 됩니다.
396p의 예제를 참고하세요.

하지만 396p의 예제가 모든 상황에서 좋은 것은 아닙니다.
데이터가 많아질수록 상위 컴포넌트가 점점 더 복잡해지기 떄문입니다.
이런 경우 하위 컴포넌트를 여러 개의 변수로 나줘서 전달하면 됩니다.
397p의 예제를 참고하세요

하지만 어떤 경우에는 하나의 데이터에 다양한 레벨에 있는 중첩된 컴포넌트들의 접근이 필요할 수 있습니다.
이런 경우라면 컨텍스트가 유리합니다.
컨텍스트는 해당 데이터와 데이터의 변경사항을 모두 하위 컴포넌트들에게 broadcast해주기 때문입니다
컨텍스트를 사용하기에 적합한 데이터의 대표적인 예로는 "지역 정보", "UI테마" 그리고 "캐싱된 데이터" 등이 있습니다.

# 컨텍스트 API

이 절에서는 리액트에서 제공하는 컨텍스트 API를 통해 컨텍스트를 어떻게 사용하는지에 대해 알아봅니다.

React.create.Context
컨텍스트를 생성하기 위한 함수 입니다.
파라메타에는 기본값을 넣어주면 됩니다.
하위 컴포넌트는 가장 가까운 상위 레벨의 provider로 부터 컨텍스트를 받게 되지만, 만일 provider를 찾을 수 없다면 아래에서 설정한 기본 값을 사용하게 됩니다.
const MyContxt = React.createContext(기본값);

# context.provider

context.provider 컴포넌트로 하위 컴포넌트들을 감싸주면 모든 하위 컴포넌트들이 해당 컨텍스트의 데이터에 접근 할 수 있게 됩니다
<MyContext.Provider value={/_ some value _/ }>
Provider 컴포넌트에는 value라는 prop이 있고, 이것은 provider 컴포넌트 하위에 있는 컴포넌트에게 전달됩니다.
하위 컴포넌트를 consumer 컴포넌트라고 부릅니다.
389p note, provider value에서 주위해야 할 사항 참고.

- Provider(제공자) 컴포넌트에는 value라는 prop이 있고, 이것은 Provider 컴포넌트 하위에 있는 컴포넌트에게 전달됩니다.
- 하위 컴포넌트를 consumer(소비자) 컴포넌트라고 부릅니다.
- Context.Consumer
- 함수형 컴포넌트에서 COntext.Consumer를 사용하여 컨텍스트를 구독 할 수 있습니다.

```jsx
<MyContext.Consumer>
    {value => /*컨텍스트의 값에 따라서 컴포넌트들을 렌더링*/}
</MyContext.Consumer>
```

- 컴포넌트의 자식으로 함수가 올 수 있는데 이것을 function as a child라고 부릅니다.
- Context.Consumer로 감싸주면 자식으로 들어간 함수가 현재 컨텍스트의 value를 받아서 리액트 노드로 리턴합니다.
- 함수로 전달되는 value는 Provider의 value prop과 **동일**합니다
  <Mycontext.Consumer>
  {value=> /_컨텍스트의 값에 따라서 컴포넌트들을 렌더링 _/}
  </Mycontext.Consumer>
  컴포넌트의 자식으로 함수가 들어갈 수 없기 때문에, 함수형 컴포넌트에서 컨텍스트를 구독하기 위해서는 함수형 컴포넌트의 자식으로 Context.Consumer를 사용해야합니다.

# Context.displayName

컨텍스트 객체는 disPlayName 이라는 문자열 속성을 갖습니다.
크롬의 리액트 개발자 도구에서는 컨텍스트의 provider나 Consumer를 표시할 때 displayName 을 함께 표시해 줍니다.

const MyContext = React.createContext(/_some value_/);
MyContext.displayName = "MyDisplayName";

//개발자 도구에 MyDisplayName.Provider"로 표시됌
MyContext.display.Provider

//개발자 도구에 MyDisplayName.Consumer"로 표시됌
MyContext.display.Consumer

#여러 개의 컨텍스트 사용하기
여러 개의 컨텍스트를 동시에 사용하려면 Context.Provider를 중첩해서 사용하면 됩니다.
예제 코드는 403 404 에 있음
예제에서는 ThemeContext와 UserContext를 중첩해서 사용하고 있습니다.
이런 방법으로 여러 개의 컨텍스트를 동시에 사용할 수 있습니다.
하지만 두개 또는 그 이상의 컨텍스트 값이 자주 함께 사용될 경우 모든 값을 한 번에 제공해주는 별도의 render prop을 사용하는 것이 좋습니다.

# useContext

함수형 컴포넌트에서 컨텍스트를 사용하기 위해 컴포넌트를 매번 Consumer 컴포넌트로 감싸주는 것보다 더 좋은 방법이 있습니다.
바로 7장에서 배운 Hook 입니다.
useContext()훅은 React.createContext()함수 호출로 생성된 컨텍스트 객체를 인자로 받아서 현재 컨텍스트의 값을 리턴합니다.
funcion MyComponent(props){
const value = useContext(MyContext);

    return(

    )

}

이 방법도 가장 가까운 상위 Provider로 부터 컨텍스트의 값을 받아 옵니다.
만일 값이 변경되면 useContext()훅을 사용하는 컴포넌트가 재렌더링 됩니다.

## 6월 5일의 강의

# shared State

1. state의 공유를 의미합니다.
2. 같은 부모 컴포넌트의 state를 자식 컴포넌트가 공유해서 사용하는 것입니다.
3. 다음 그림은 부모 컴포넌트가 섭씨 온도의 state를 갖고 있고, 이것을 컴포넌트c와 컴포넌트f가 공유해서 사용하는 것을 보여줍니다.

정리하자면 상위 컴포넌트인 calculator에서 온도와 단위를 state로 갖고,

합성은 여러개의 컴포넌트를 합쳐서 새로운 컴포넌트를 만드는것입니다.
조합 방법에 따라 합성의 사용 기법은 다음과 같이 나눌 수 있습니다.
composition

# containmetnt(담다, 포함하다, 격리하다)

특정 컴포넌트가 하위 컴포넌트를 포함하는 형태의 합성 방법입니다.
컴포넌트에 따라서는 어떤 자식 엘리먼트가 들어올 지 미리 예상할 수 없는 경우가 있습니다.
범용적인 박스 역할을 하는 side bar 컴포넌트를 예로 들 수 있습니다.
이런 컴포넌트에서는 children prop을 사용하여 자식 엘리먼트를 출력에 그대로 전달하는 것이 좋습니다.
이때 children prop은 컴포넌트의 props에 기본적으로 들어있는 children속성을 사용합니다.

## 5월 29일 강의

# textarea 태그

# File input 태그

이 태그는 그 값이 읽기 전용이기 때문에 리액트에서는 비제어 컴포넌트가 됩니다.
Input Null Value
제어 컴포넌트에 value prop을 정해진 값으로 넣으면 코드를 수정하지 않는 한 입력값을 바꿀 수 없습니다.
만약 value prop 은 넣되 자유롭게 입력할 수 있게 만들고 싶다면 값이 undefined 또는 null을 넣어주면 됩니다.

ReactDom.render(<input value ="hi" />, rootNode);

setTimeout(function() {
ReactDom.render(<input value={null}/>, rootNode);
},1000);

## 5월 22일 강의

1. 리스트는 자바스크립트의 변수나 객체를 하나의 변수로 묶어 놓은 배열과 같은 것
2. 키는 각 객체나 아이템을 구분할 수 있는 고유한 값을 의미
3. 리액트에서 배열과 키를 사용하는 반복되는 다수의 엘리먼트를 쉽게 렌더링할 수 있음
4. 리스트에서의 키는 "리스트에서 아이템을 구별하기 위한 고유한 문자열"
5. 이 키는 리스트에서 어떤 아이템이 변경, 추가 또는 제거되었는지 구분하기 위해 사용
6. 키는 같은 리스트에 있는 엘리먼트 사이에서만 고유한 값이면 됨
7. 폼은 일반적으로 사용자로부터 입력을 받기위한 양식에서 많이 사용됨

## 5월8일

# 이벤트 처리하기

Dom 과 React의 이벤트 처리하는 차이

이벤트 이름이 onclick 에서 onClick 으로 변경 camelcase
전달하려는 함수는 문자열에서 함수 그대로 전달
이벤트가 발생했을 떄 해당 이벤트를 처리하는 함수를 이벤트 핸들러 라고 합니다. 또는 이벤트가 발생하는 것을 계속 들고 있다는 의미로 event handler 라고 합니다.

이벤트 핸들러를 추가하는 방법은 ? 버튼을 클릭하면 이벤트 핸들러 함수인 handeclick()함수를 호출하도록 되어 있습니다.
bind 를 사용하지 않으면 this.handelClick은 글로벌 스코프에서 호출되어 undefind 으로 사용할 수 없기 때문입니다.

bind 를 사용하지 않으려면 화살표 함수를 사용하는 방법도 있습니다.
하지만 클래스 컴포넌트는 이제 거의 사용하지 않기 때문에 이 내용은 참고만 합니다.

클래스형을 함수형으로 바꾸면 다음 코드와 같습니다.
함수형에서 이벤트 핸들러를 정의하는 방법은 두가지 입니다.
함수형에서는 this를 사용하지 않고 onClick에서 바로 handleClick을 넘기면 됩니다.

# arguments

함수를 정의할 때는 파라미터 혹은 매개변수
함수를 사용할 때는 아규먼트 혹은 인수라고 부릅니다.
이벤트 핸들러에 매개변수를 전달해야 하는 경우도 많습니다.

event라는 매개변수는 리액트의 이벤트 객체를 의미합니다.
두 방법 모두 첫번 째 매개 변수는 id 이고 두번 째 매개변수로 event가 전달 됩니다.,
첫번 째 코드는 명시적으로 event를 매개변수로 넣어주었고 두번 째 코드는 id 이후 두번 째 매개변수로 event가 자동 전달됩니다.(이 방법은 클래스형에서 사용하는 방법입니다.)
함수형 컴포넌트에서 이벤트 핸들러에 매개변수를 전달할 때는 254p 코드와 같이 작동합니다.

인라인 if

if 문을 직접 사용하지 않고, 동일한 효과를 내기 위해 && 논리 연산자를 사용합니다.
&&는 and 인자로 모든 조건이 "참" 일때만 참이 됩니다.
첫번 째 조건이 거짓이면 두번 째 조건은 판단할 필요가 없습니다. 단축평가.
판단만 하지 않는 것이고 결과 값은 그대로 리턴됩니다.

## 5월1일

DOM 에서 클릭 이벤트를 처리하는 예제 코드.
<button onclick = "activate()">
Activate
</button>

React에서 클릭 이벤트를 처리하는 예제 코드.
<button onclick = "(activate)">
Activate
</button>

이 둘의 차이점은

1. 이벤트 이름이 onclick에서 onClick으로 변경.(Camel case)
2. 전달할려는 함수는 문자열에서 함수 그대로 전달.

이벤트가 발생했을 때 해당 이벤트를 처리하는 함수를 이벤트 핸들러 라고 합니다.

# 이벤트 핸들러 추가하는 방법은 ?

버튼을 클릭하면 이벤트 핸들러 함수인 handleClick() 함수를 호출하도록 되어 있습니다.
bind 를 사용하지 않으면 this.handleClick()은 글로벌 스코프에서 호출되어, undefined으로 사용할 수 없기 때문입니다.
bind 를 사용하지 않으려면 화살표 함수를 사용하는 방법도 있습니다.
하지만 클래스 컴포넌트는 이제 거의 사용하지 않기 때문에 이 내용은 참고만 합니다.

## 4월 17일 강의 내용

# 훅이란 무엇인가?

1. 클래스형 컴포넌트에서는 생성자(constructor)에서 state를 정의하고, setState()함수를
   통해 state를 업데이트 합니다.

2. 예전에 사용하던 함수형 컴포넌트는 별도로 state를 정의하거나, 컴포너트의 생명주기에 맞춰서
   어떤 코드가 실행되도록 할 수 없었습니다.
   함수형 컴포넌트에서도 state나 생명주기 함수의 기능을 사용하게 해주기 위해 추가된 기능이 바로 훅 (hook)입니다.

3. 함수형 컴포넌트도 훅을 사용하여 클래스형 컴포넌트의 기능을 모두 동일하게 구현 할 수 있게 되었습니다.

4. hook 이란 'state'와 생명주기 기능에 갈고리를 걸어 원하는 시점에 정해진 함수를 실행
   되도록 만든 함수를 의미합니다.

   훅의 이름은 모두 use로 시작합니다.

   사용자 정의 훅(custom hook)을 만들수 있으며, 이 경우에 이름은 자유롭게 할 수 있으나
   'use'로 시작할 것을 권장합니다.

# useState

1.  useState는 함수형 컴포넌트에서 state를 사용하기 위한 hook 입니다.

2.  다음 예제는 버튼을 클릭할 때마다 카운트가 증가하는 함수형 컴포넌트 입니다.
    하지만 증가는 시킬 수 있지만 증가할 때마다 재 렌더링은 일어나지 않습니다.
    이럴 때 state를 사용해야 하지만 함수형에는 없기 때문에 useState()를 사용합니다.

    import React, {useState} from "react";

            function Counter(props){
                var count = 0;

                return(
                    <div>
                        <p> 총 {count}번 클릭했습니다. </p>
                        <button onClick={() => count++}>클릭</button>
                    <div/>
                    );
                }

# useEffect

useState와 함께 가장 많이 사용하는 Hook 입니다.

이 함수는 사이드 이펙트를 수행하기 위한 것입니다.

영어로 side effect는 부작용을 의미합니다. 일반적으로 프로그래밍에서 사이트 이펙트는 개발자가 의도하지 않은 코드가 실행되면서 버그가 발생하는 것을 말합니다.

하지만 리액트에서는 효과 또는 영향을 뜻하는 effect의 의미에 가깝습니다.

예를 들면 서버에서 데이터를 받아오거나 수동으로 DOM을 변경하는 등의 작업을 의미합니다.

이작업을 이펙트라고 부르는 이유는 이 작업들이 다른 컴포넌트에 영향을 미칠 수 있으며, 렌더링 중에는 작업이 완료될 수 없기 때문입니다. 렌더링이 끝난 이후에 실행 되어야 하는 작업들 입니다.

클래스 컴포넌트의 생명 주기 함수와 같은 기능을 하나로 통합한 기능을 제공합니다.

저자는 useEffect가 side effect가 아니라 effect에 가깝다고 설명하고 있지만, 이것은 부작용의 의미를 잘못 해석해서 생긴 오해이다.

결국 sideEffect는 렌더링 외에 실행해야 하는 부수적인 코드를 말합니다.
예를 들면 네트워크 리퀘스트, DOM수동조작, 로깅 등은 정리 (clean-up)가 필요 없는 경우들입니다.

useEffect()함수는 다음과 같이 사용합니다.

첫 번째 파라미터는 이펡트 함수가 들어가고, 두 번째 파라미터로는 의존성 배열이 들어갑니다.
useEffect(이펙트 함수, 의존성 배열);
의존성 배열은 이펙트가 의존하고 있는 배열로 배열 안에 있는 변수 중에 하나라도 값이 변경되었을 때, 이펙트 함수가 실행됩니다.
이펙트 함수는 처음 컴포넌트가 렌더링 된 이후, 그리고 재렌더링 이후에 실행됩니다.
만약 이펙트 함수가 마운트 와 언마운트 될 때만 한 번씩 실행되게 하고 싶으면 빈 배열을 넣으면 됩니다.
이 경우 props나 state에 있는 어떤 값에도 의존하지않기 때문에 어러번 실행되지 않습니다.

useEffect(() => {
//컴포넌트가 마운트 된 이후,
//의존성 배열에 있는 변수들 중 하나라도 값이 변경되었을 때 실행됨.
})

useMemo() 훅은 Memoizde value를 리턴하는 훅입니다.
이전 계산 값을 갖고 있기 때문에 연산량이 많은 작업의 반복을 피할 수 있습니다.
이 훅은 렌더링이 일어나는 동안 실행됩니다.
따라서 렌더링이 일어나는 동안 실행돼서는 안될 작업을 넣으면 안됩니다.
예를 들면 useEffect에서 실행되어야 할 사이드 이펙트 같은 것입니다.
const memoizedValue = useMemo(
() => {
//연산량이 높은 작업을 수행하여 결과를 반환
return computeExpensiveValue(의존성 변수1, 의존성 변수2);
},
[의존성 변수1, 의존성 변수2]
)

# 메모이제이션

다음 코드와 같이 의존성 배열을 넣지 않을 경우, 렌더링이 일어날 때마다 매번 함수가 실행됩니다.

따라서 의존성 배열을 넣지 않는 것은 의미가 없습니다.

만약 빈 배열을 넣게 되면 컴포넌트 마운트 시에만 함수가 실행됩니다.

const memoizedValue = useMemo(
()=> computeExpensiveValue(a,b)
);

# useCallback

useCallback() 훅은 useMemo()와 유사한 역할을 합니다.

차이점은 값이 아닌 함수를 반환한다는 점입니다.

의존성 배열을 파라미터로 받는 것은 useMemo와 동일합니다.

파라미터로 받은 함수를 콜백이라고 부릅니다.

useMemo와 마찬가지로 의존성 배열 중 하나라도 변경 되면 콜백함수를 반환합니다.

const memoizedCallback = useCallback(
() => {
doSomething(a, b);
};
[a, b]
);

# useRef

useRef()훅은 헤퍼런스를 사영하기 위한 훅입니다.

레퍼런스란 특정 컴포넌트에 접근할 수 있는 객체를 의미합니다.

useRef()훅은 바로 이 레퍼런스 객체를 반환합니다.

레퍼넌스 객체에는 .current라는 속성이 있는데, 이것은 현재 참조하고 있는 엘리먼트를 의미합니다.
const refContainer = useRef(초깃값);

이렇게 반환된 레퍼런스 객체는 컴포넌트의 라이프타임 전체에 걸쳐서 유지됩니다.

즉, 컴포넌트가 마운트 해제전까지는 계속 유지된다는 의미입니다.

# 훅의 규칙

첫번째 규칙은 무조건 최상의 레벨에서만 호출해야 된다는 것 입니다.

여기서 최상위는 컴포넌트 의 최상위 레벨을 의미합니다.

따라서 반복문이나 조건문 또는 중처된 함수들 안에서 훅을 호출하면 안됩니다.

이 규칙에 따라서 휵은 컴포넌트가 렌더링 될 때마다 같은 순서로 호출되야합니다.

## 4월 3일 강의 내용

# 컴포넌트에 대해 알아보기

2장에서 설명한 바와 같이 리액트는 "컴포넌트 기반의 구조" 를 갖고 있습니다.
"컴포넌트 구조" 라는 것은 작은 컴포넌트가 모여 큰 컴포넌트를 구성하고 이런 컴포넌트들이 모여서 전체 페이지를 구성한다는 것을 의미합니다.

컴포넌트는 재사용이 가능하기 때문에 전체 코드의 양을 줄일 수 있었고, 개발시간과 유지보수 비용도 줄 일 수 있습니다.
컴포넌트는 자바 스크립트 함수처럼 입력과 출력이 있다는 면에서는 우사합니다.
다만, 입력은 "props" 가 담당하고 출력은 리액트 엘리먼트의 형태로 출력됩니다.

# props의 개념

props 는 prop(property 속성 특성)의 줄임말 입니다.
이 props가 바로 컴포넌트의 속성입니다.
컴포넌트에 어떤 속성(props)을 넣느냐에 따라서 속성이 다른 엘리먼트가 출력됩니다.
props 는 컴포넌트에 전달 할 다양한 정보를 담고 있는 자바스크립트 객체 입니다.

에어비앤비의 예도 마찬가지입니다.

# props 의 특징

읽기 전용입니다. -> 변경할 수 없다는 의미를 나타냅니다.
속성이 다른 엘리먼트를 생성하려면 새로운 props 를 컴포넌트에 전달하면 됩니다.

pure함수 vs impure함수

pure함수는 인수로 받은 정보가 함수 내부에서도 "변하지 않는 함수" 입니다.
impure 함수는 인수로 받은 정보가 함수 내부에서 "변하는 함수" 입니다.

jsx에서는 key-value쌍으로 props를 구성합니다.

function App(props){
return (
<profile/>
name = "소플"
introduction = "안녕하세요, 소플입니다."
viewCount = {1500}
);
}

위 코드는

1. App 컴포넌트에서 props를 인자로 받아
2. 내부의 Profile 컴포넌트로 전달해서 name, introduction, viewCount에 각각 속성을 할당하는
3. 이때 전달되는 props 는 다음과 같은 자바스크립트 객체입니다.

{
name = "소플"
introduction = "안녕하세요, 소플입니다."
viewCount = {1500}
}

JSX에서는 중괄호를 사용하면 JS 코드를 넣을 수 있다고 배웠습니다.
다음 코드처럼 props를 통해서 value를 할당 할 수도 있고, 직접 중괄호를 사용하여 할당할 수도 있습니다.

function aApp(props){
return (
<Layout
width = {2500}
height = {1440}
header = {
Header title = "소플의 블로그 입니다."

);
Footer={
< footer />
}
}

JSX를 사용하지 않는 경우 props의 전달 방법은 createElement()함수를 사용하는 것 입니다.

createElement()함수의 두번째 매개변수가 바로 props입니다.
JSX를 사용하지 않으면 다음과 같이 코드를 작성할 수 있습니다.

React.create

# 컴포넌트의 종류

리액트 초기버전을 사용할 때는 클래스형 컴포넌트를 주로 사용했습니다.
이후 Hook이라는 개념이 나오면서 최근에는 함수형 컴포넌트를 주로 사용합니다.
예전에 작성된 코드나 문서들이 클래스형 컴포넌트를 사용하고 있기 때문에,
클래스형 컴포넌트와 컴포넌트의 생명주기에 관해서도 공부해 두어야합니다.

# 함수형 컴포넌트

welcome 컴포넌트는 props 를 받아, 받은 props중 name키의 값을 "안녕", 뒤에 넣어 반환합니다.
function Welcome(props){
return<h1>안녕, {props.name}</h1>;
}

컴포넌트 이름 짓기
이름은 항상 대문자로 시작합니다.
왜냐하면 리액트는 소문자로 시작하는 컴포넌트를 DOM 태그로 인식하기 때문입니다. html tag.\*컴포넌트 파일 이름과 컴포넌트 이름을 같게 합니다.

# 컴포넌트의 렌더링

렌더링의 과정은 다음 코드와 같습니다.

function Welcome(props){
return<h1>안녕, {props.name}</h1>;
}

const element = <Welcome name = "인제" />;
ReactDOM.render(
element,
document.getElementById('root')
);

# 자주하는 실수 파일 위치 보기

# 컴포넌트 합성

컴포넌트 합성은 여러개의 컴포넌트를 합쳐서 하나의 컴포넌트를 만드는 것 입니다.
리액트에서는 컴포넌트 안에 또 다른 컴포넌트를 사용할 수 있기 때문에 복잡한 활면을 여러개의 컴포넌트로 나누어 구현할 수 있습니다.
다음 코드에서는 props 의 값을 다르게 해서 Welcome 컴포넌트를 여러번 사용합니다.

# 컴포넌트 추출

복잡한 컴포넌트를 쪼개서 여러 개의 컴포넌트로 나눌 수도 있습니다.
큰 컴포넌트에서 일부를 추출해서 새로운 컴포넌트를 만드는 것 입니다.
실무에서는 처음부터 1개의 컴포넌트에 하나의 기능만 사용하도록 설계하는 것이 좋습니다.

comment 는 댓글 표시 컴포넌트 입니다.
내부에는 이미지, 이름, 댓글과 작성일이 포함되어 있습니다.

# State란 ?

State는 리액트 컴포넌트의 상태를 의미합니다.
상태의 의미는 정상인지 비정상인지가 아니라 컴포넌트의 데이터를 의미합니다.
정확히는 컴포넌트의 변경 가능한 데이터를 의미합니다.
State가 변하면 다시 렌더링이 되기 때문에 렌더링과 관련된 값만 state에 포함시켜야 합니다.

# State의 특징

리액트 만의 특별한 형태가 아닌 단지 자바스크립트 객체일 뿐입니다.
예의 LikeButton은 class 컴포넌트 입니다.
constructor는 생성자이고 그 안에 있는 this,state가 현 컴포넌트의 state입니다.

함수형 에서는 useState()라는 함수를 사용합니다.

state는 변경은 가능하다고 했지만 직접 수정해서는 안됩니다.
불가능 하다고 생각하는 것이 좋습니다.
state를 변경하고자 할 때는 setstate() 함수를 사용합니다.

element = 재료
component = 빵 틀
instance = 재료를 빵 틀에 넣고 만든 빵

# 생명주기에 대해 알아보기

생명주기는 컴포넌트의 생성 시점, 사용 시점, 종료 시점을 나타내는 것입니다.
constructor 가 실행되면서 컴포넌트가 생성됩니다.
생성 직후 componentDidMount()함수가 호출됩니다.
컴포넌트가 소멸하기 전까지 여러 번 렌더링 합니다.
렌더링은 props, setState(), forceUpdate()에 의해 상태가 변경되면 이루어집니다.
그리고 렌더링이 끝나면 componentDidMount() 함수가 호출됩니다.
마지막으로 컴포넌트가 언마운트 되면 componentWillUnmount() 함수가 호출됩니다.

## 3월 27일 강의 내용

# JSX 란?

JSX는 내부적으로 xml/html 코드를 자바스크립트로 변환합니다.
React가 createElement 함수를 사용하여 자동으로 자바스크립트로 변환해줍니다.
만일 JS 작업할 경우 직접 createElement 함수를 사용해야합니다.
앞으로 설명하는 코드를 보면 알 수 있지만 결국 JSX는 가독성을 높여주는 역할을 합니다.

장점

1. 코드가 간결해 집니다.
2. 가독성이 향상 됩니다.
3. injection attack 이라 불리는 해킹 방법을 방어함으로써 보안에 강합니다.
4. 모든 자바 스크립트 문법을 지원합니다.
5. 자바스크립트 문법에 xml 과 html을 섞어서 사용합니다.
   아래 코드의 2번 라인처럼 섞어서 사용하는 것입니다.
   만일 html이나 xml에 자바스크립트 코드를 사용하고 싶으면 { } 괄호를 사용합니다.

만일 태그의 속성값을 넣고 싶을 때는 다음과 같이 합니다.

const element = <div tabIndex="0"></div>;
const element = <img src={user.avatarUrl}></img>;

# 엘리먼트 정의

엘리먼트는 리액트 앱을 구성하는 요소를 의미합니다.
공식페이지에는 "엘리먼트는 리액트 앱의 가장 작은 빌딩 블록들" 이라고 설명하고 있습니다.
웹사이트의 경우는 dom 엘리먼트이며 html요소를 의미합니다.

리액트 엘리먼트와 dom 엘리먼트의 차이는 ?

리액트 엘리먼트는 virtual dom의 형태를 취하고 있습니다.
dom 엘리먼트는 페이지의 모든 정보를 갖고 있어 무겁습니다.
반면 리액트 엘리먼트는 변화한 부분만 갖고 있어 가볍습니다.

업데이트 속도 : dom 은 느리고, virtual dom 빠릅니다.
element 업데이트 방식은 : dom전체 업데이트, 변화 부분을 가상 dom 으로 만든 후 dom과 비교하여 다른 부분만 업데이트.
메모리 : dom 낭비가 심함, virtual dom 효율적이다.

역시 자바스크립트 객체입니다.

내부적으로 자바스크립트 객체를 만드는 역할을 하는 함수가 createElement()입니다.
첫 번째 매개변수가 type 입니다. 이 곳에 태그가 들어가면 그대로 표현하고,
만일 리액트 컴포넌트가 들어가면 이것을 분해해 결국 태그로 만들게 됩니다.

엘리먼트의 생김새 -> 리액트 엘리먼트는 자바스크립트 객체의 형태로 존재합니다.

# 특징

가장 큰 특징은 불변성입니다.
즉, 한 번 생성된 엘리먼트의 children 이나 속성을 바꿀 수 없습니다.

만일 내용이 바뀌면 어떻게 해야 할까요 ?
이 때는 컴포넌트를 통해 새로운 엘리먼트를 생성하면 됩니다.
그 다음 이전 엘리먼트와 교체를 하는 방법으로 내용을 바꾸는 것입니다.
이렇게 교체하는 작업을 하기 위해 virtualdom을 사용합니다.

root dom node = 최상위
다음 html 코드는 id 값이 root인 div 태그로 단순하지만 리액트에 필수로 들어가는 아주 중용한 코드입니다.
이 div 태그 안에 리액트 엘리먼트가 렌더링 되며, 이것을 root dom node 라고 합니다.

<div id = "root"></div>

엘리먼트를 렌더링하기 위해서는 다음과 같은 코드가 필요합니다.

const element = <h1>안녕, 리액트!</h1>
ReactDOM.render(element, document.getElementById('root'));

이때 render()함수를 사용하게 됩니다.
이 함수의 첫 번째 파라메터 출력할 리액트 엘리먼트이고, 두번째 파라메터는 출력할 타겟을 나타냅니다.
즉 리액트 렌터링의 과정은 virtyal dom 에서 실제dom으로 이동하는 과정이라고 할 수 있습니다.

## 3월 20일 강의 내용

creat-react-app 생성 방법

1. Node.js 설치 (맥의 경우 brew install node 윈도우의 경우 사이트가서 설치)
2. npm 설치 (npm install -g npm \*brew로 설치시 npm 자동 설치)
3. npm 버전 확인 npm -v
4. npx 설치 (터미널 -> npm install npx -g)
5. npx 버전 확인 npx -v
6. create-react-app 설치 (터미널 -> npx -> npx create-react-app 본인 디렉토리 이름)
7. test.app 생성하기

8. 리액트의 장점 - 빠른 업데이트와 렌더링 속도 (렌더링이란, 화면에 띄워주는게 빠르다.)
   ㄴ> 이것을 가능하게 하는 것이 바로 Virtual DOM 입니다.
   DOM(Document Object Model)은 HTML 문서를 객체로 만들어 놓은 것입니다.
   Virtual DOM은 DOM 조작이 비효율적인 이유로 속도가 느리기 때문에 고안된 방법입니다.
   DOM은 동기식, Virtual DOM은 비동기식 방법으로 렌더링합니다.

9. 컴포넌트 기반구조
   리액트의 모든 페이지는 컴포넌트로 구성됩니다.
   하나의 컴포넌트는 다른 여러 개의 컴포넌ㄴ트의 조합으로 구성할 수 있습니다.
   그래서 리액트로 개발을 하다 보면 레고 블록을 조립나는 것처럼 컴포넌트를 조합해서 웹사이트를 개발하게 됩니다.
   아래 그림은 에어비앤비 사이트 화면의 컴퐅넌트 구조 입니다. 재사용성이 뛰어납니다.

10. 재사용성
    반복적인 작업을 줄여주기 때문에 생산성을 높여 줍니다.
    또한 유지보수가 용이합니다.
    재사용이 가능하려면 해당 모듈의 의존성이 없어야 합니다.

11. 든든한 지원군
    메타(facebook)에서 오픈소스 프로젝트로 관리하고 있어 계속 발전하고 있습니다.

12. 활발한 지식 공유 & 커뮤니티

13. 모바일 앱 개발가능
    리액트 네이티브 라는 모바일 환경 UI프레임워크를 사용하면 크로스 플랫폼(cross-platform)모바일 앱을 개발할 수 있습니다.

1-3 리액트의 단점

1. 방대한 학습량 - 자바스크립트를 공부한 경우 빠르게 학습할 수 있습니다.
2. 높은 상태 관리 복잡도 - state, component life cycle 등의 개념이 있지만 그리 어렵지 않습니다.

gitignore -> 제외할 파일 목록을 지정하는 파일이다.
git으로 프로젝트를 관리할 때, 그 프로젝트 안의 특정파일들은 Git으로 관리할 필요가 없는 경우가 있다.

## 3월 13일 강의 내용

---

git 사용 방법 정리

1. 해야할 일을 이슈로 가서 제작
2. (local/origin) git pull upstream/origin master -rebase
3. 이슈 번호로 새로운 브런치 생성
4. 작업
5. (local/no) git commit -am "?" ? = 이슈명("커밋 #3") git add . git commit -m "커밋"
6. git pull upstream/origin master —rebase (새로운 master를 가져오기 위함)
7. conflict 해결 (존재 한다면)
8. git push origin "branch name" \*강제 push 는 -f 붙이기 (push -f origin)
9. github 들어가서 PR 올리기
10. Upstream에 murge 된 후에 Branch 삭제하기. \*모든 작업이 끝나기 전엔 Branch 지우지않기.

VIM
q : 나가기
wq : 저장 후 나가기
i = insert : 입력 모드
esc : 입력모드 종료

Branch
git switch name name은 (바꾸려는 브런치 명)
git switch -c name name은 (브런치 생성과 변경)
git branch (브런치 목록 확인)
git branch -d name (브런치 삭제) \* D를 사용 시 강제 삭제...

Rebase
git rebase -i HEAD~4 4은 (보여줄 커밋의 숫자를 의미함 더 많이 더 적게도 됌.)
git rebase --abort : Rebase 취소
git rebase --continue : Rebase 계속 (충돌)

충돌 발생 시 반복
충돌 하나 수정 -> git add . ->git rebase --continue

합칠 때 둘 중 아래(최신)있는 커밋을 pick -> s (squash)로 바꾸고 저장.

기타
git stash : 마지막 커밋 이후에 모든 변경사항 숨겨짐.
git stash pop : 마지막 나타나게 함.
git commit --amend 가장 최근의 커밋을 수정할 수 있음. \* 주로 커밋이름 바꿀 때 씀.

---

var = 중복 선언 가능 재할당 가능
Let = 중복 선언 불가능 재할당 가능
Const = 중복 선언 불가능 재할당 불가능
Array type = 배열
Object type

Ecma 스크립트

화살표 함수의 객체 부분을 잘 이해하자.

### GitHub 사용법
